<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Coupled Oscillators — Interactive Charts</title>
<script src="https://cdn.plot.ly/plotly-2.32.0.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
<style>
:root { --pad: 14px; }
body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;margin:0;background:#0b0c10;color:#e8e8e8}
header{padding:var(--pad);border-bottom:1px solid #222;background:#111217;position:sticky;top:0;z-index:5}
h1{margin:0 0 6px;font-size:20px}
.muted{color:#9aa3b2;font-size:12px}
.card{background:#14161d;border:1px solid #1f2330;border-radius:12px;padding:var(--pad)}
.wrap{display:grid;gap:16px;grid-template-columns:320px 1fr;padding:var(--pad)}
.controls label{display:block;font-size:12px;margin:8px 0 6px;color:#cfd3dc}
textarea,input,button{width:100%;box-sizing:border-box;font:inherit;padding:8px;border-radius:8px;border:1px solid #2b3245;background:#0f1117;color:#e8e8e8}
button{cursor:pointer}
.grid-2{display:grid;grid-template-columns:1fr 1fr;gap:8px}
.toolbar{display:flex;justify-content:space-between;align-items:center;gap:10px;margin-bottom:8px;flex-wrap:wrap}
.viewbar{display:inline-flex;gap:8px;align-items:center}
.viewbar button{width:auto;padding:6px 10px}
button.active{background:#1d2433;border-color:#3a4a6a;box-shadow:0 0 0 2px rgba(110,168,254,.35)}
.row{display:grid;gap:14px;grid-template-columns:1fr 1fr}
.row.cols1{grid-template-columns:1fr}
.row.cols3{grid-template-columns:1fr 1fr 1fr}
.plot{min-height:520px;background:#0e1016;border:1px solid #1f2330;border-radius:10px}
.js-plotly-plot .gtitle{white-space:normal!important}
.js-plotly-plot .main-svg{overflow:visible!important}
.plots-pane{position:sticky;top:52px;align-self:start;height:calc(100vh - 60px);overflow:auto}
@media (max-width: 980px){
  .wrap{grid-template-columns:1fr}
  .plots-pane{position:static;height:auto}
}
.opts{display:flex;gap:10px;align-items:center;flex-wrap:wrap;margin:6px 0 10px}
.opts label{display:flex;gap:6px;align-items:center;margin:0}
</style>
</head>
<body>
<header>
  <h1>Coupled Oscillators — Interactive Charts</h1>
  <div class="muted">Header & controls stay fixed. Graphs have their own scroll area. Double-click a plot to fullscreen. Use identity (y=x), LS fit, and LOWESS to assess dynamics.</div>
</header>

<div class="wrap">
  <!-- Controls -->
  <div class="card controls">
    <h2>Startup Box — Quick X/Y</h2>
    <label>X values (comma/space/newline-separated)</label>
    <textarea id="xvals" placeholder="e.g., 1, 2, 3, 4"></textarea>
    <label>Y values (same length as X)</label>
    <textarea id="yvals" placeholder="e.g., 2, 4, 3, 6"></textarea>
    <div class="grid-2">
      <button id="btn-scatter">Make Scatter</button>
      <button id="btn-line">Make Connected Line</button>
    </div>
    <hr style="border-color:#1f2330;margin:14px 0">

    <h2>Upload CSVs</h2>

    <label>Hare–Lynx CSV (flexible headers: Year/Hare/Lynx)</label>
    <input type="file" id="file-hl" accept=".csv"/>

    <label>Fitbit by-minute CSV (flexible: timestamp/time + steps/value)</label>
    <input type="file" id="file-fitbit" accept=".csv"/>

    <label>Tribolium CSV (flexible: t/index/time + Adults/population/value)</label>
    <input type="file" id="file-trib" accept=".csv"/>

    <label>Mites (Predator–Prey) CSV (flexible: time + prey + predator)</label>
    <input type="file" id="file-mites" accept=".csv"/>

    <div class="opts">
      <label><input type="checkbox" id="cb-decum" checked> De-cumulative fix (if your series are running totals)</label>
      <label><input type="checkbox" id="cb-znorm" checked> Z-normalize for phase & returns</label>
    </div>

    <div class="grid-2" style="margin-top:6px">
      <button id="btn-make-lynx">Phase & Return (HL)</button>
      <button id="btn-make-fitbit">Rose & Radar</button>
    </div>
    <div class="grid-2" style="margin-top:6px">
      <button id="btn-make-trib">Cobweb (Tribolium)</button>
      <button id="btn-make-mites">Mites: Phase & Returns</button>
    </div>
    <div class="grid-2" style="margin-top:6px">
      <button id="btn-clear">Clear Plots</button>
      <button id="btn-clear-files">Clear Files</button>
    </div>
    <p class="muted" style="margin-top:8px">Tip: camera icon downloads a PNG.</p>
  </div>

  <!-- Plots -->
  <div class="card plots-pane">
    <div class="toolbar">
      <div class="viewbar">
        <span class="muted">View:</span>
        <button id="view-1">1-up</button>
        <button id="view-2" class="active">2-up</button>
        <button id="view-3">3-up</button>
      </div>
      <div class="muted" id="status">Ready.</div>
    </div>
    <div class="row cols2" id="plot-row">
      <div id="plot1" class="plot"></div>
      <div id="plot2" class="plot"></div>
      <div id="plot3" class="plot"></div>
      <div id="plot4" class="plot"></div>
      <div id="plot5" class="plot"></div>
      <div id="plot6" class="plot"></div>
    </div>
  </div>
</div>

<script>
const config = { responsive: true, displaylogo: false };
const rowEl = document.getElementById("plot-row");
const viewBtns = [document.getElementById("view-1"), document.getElementById("view-2"), document.getElementById("view-3")];
const setCols = n => { rowEl.className = "row cols"+n; viewBtns.forEach(b=>b.classList.remove("active")); viewBtns[n-1].classList.add("active"); };
viewBtns[0].onclick = ()=>setCols(1);
viewBtns[1].onclick = ()=>setCols(2);
viewBtns[2].onclick = ()=>setCols(3);

function setStatus(msg, bad=false){ const el=document.getElementById("status"); el.style.color=bad?"#ffb4b4":"#9aa3b2"; el.textContent=msg; }
function clearPlots(){ for(let i=1;i<=6;i++) Plotly.purge("plot"+i); setStatus("Cleared."); }
function clearFiles(){ ["file-hl","file-fitbit","file-trib","file-mites"].forEach(id=>{const el=document.getElementById(id); if(el) el.value="";}); setStatus("File picks cleared."); }
document.getElementById("btn-clear").onclick = clearPlots;
document.getElementById("btn-clear-files").onclick = clearFiles;

function toNumber(v){ if(v==null) return null; if(typeof v==="number"&&Number.isFinite(v)) return v;
  let s=String(v).trim(); if(!s) return null; s=s.replace(/(?<=\d)[\s,](?=\d)/g,""); const pct=/%$/.test(s); s=s.replace(/%$/,"");
  const n=Number(s); if(!Number.isFinite(n)) return null; return pct?n/100:n;
}
function toNumberArray(arr){ return arr.map(toNumber).filter(v=>v!=null); }
function toDate(val){ if(val==null||val==="") return null; if(val instanceof Date && !isNaN(val)) return val;
  if(typeof val==="number"){ const ms = val>=1e12?val:(val>=1e9?val*1000:val); const d=new Date(ms); return isNaN(d)?null:d; }
  const s=String(val).trim(); let d=new Date(s); if(!isNaN(d)) return d; d=new Date(s.replace(/-/g,"/")); return isNaN(d)?null:d;
}
function normKey(k){ return String(k||"").toLowerCase().replace(/[^a-z0-9]+/g,"").trim(); }
function pickColumn(rows, opts, {fallbackNumeric=false}={}){
  if(!rows?.length) return null; const map={}; Object.keys(rows[0]).forEach(k=>map[normKey(k)]=k);
  for(const opt of opts){ const nk=normKey(opt); if(nk in map) return map[nk]; }
  if(fallbackNumeric){ for(const c of Object.keys(rows[0])){ const vals=rows.slice(0,Math.min(30,rows.length)).map(r=>toNumber(r[c])); const ok=vals.filter(v=>v!=null).length>=Math.ceil(vals.length*0.6); if(ok) return c; } }
  return null;
}
function readCSV(file, cb){
  Papa.parse(file, { header:true, skipEmptyLines:true, dynamicTyping:false,
    complete: res=>{ if(res.errors?.length) setStatus("CSV warnings: "+res.errors[0].message, true); else setStatus(`Loaded ${file.name} (${res.data.length} rows)`); cb(res.data); },
    error: err=> setStatus("CSV parse error: "+err, true)
  });
}
function baseLayout(titleText, extra={}){
  return Object.assign({
    title:{ text:titleText, x:0.02, xanchor:"left", font:{size:16}},
    margin:{ t:56, r:40, b:60, l:70 },
    xaxis:{ title:{text:""}, automargin:true, tickfont:{size:11}, titlefont:{size:12}},
    yaxis:{ title:{text:""}, automargin:true, tickfont:{size:11}, titlefont:{size:12}},
    hoverlabel:{ font:{size:11}}
  }, extra);
}
function polarLayout(titleText, extra={}){
  return Object.assign({
    title:{ text:titleText, x:0.02, xanchor:"left", font:{size:16}},
    margin:{ t:56, r:30, b:40, l:30 },
    polar:{ angularaxis:{direction:"clockwise", tickfont:{size:11}},
            radialaxis:{tickfont:{size:11}, angle:0, ticks:"outside"} },
    hoverlabel:{ font:{size:11}}
  }, extra);
}

// ---------- Quick X/Y ----------
function parseSeries(t){ if(!t) return []; return toNumberArray(t.replace(/[;,\t\r\n]+/g," ").trim().split(/\s+/)); }
document.getElementById("btn-scatter").onclick = ()=>{
  const xs=parseSeries(document.getElementById("xvals").value);
  const ys=parseSeries(document.getElementById("yvals").value);
  if(xs.length!==ys.length||xs.length<2){ setStatus("X and Y must be same length (≥2).", true); return; }
  Plotly.newPlot("plot1",[{x:xs,y:ys,mode:"markers",type:"scatter"}], baseLayout("Custom Scatter (X vs Y)",{xaxis:{title:{text:"X"}},yaxis:{title:{text:"Y"}}}), config);
};

// ---------- Hare–Lynx (unchanged core; sorts by year) ----------
document.getElementById("btn-make-lynx").onclick = ()=>{
  const f=document.getElementById("file-hl").files[0]; if(!f) return setStatus("Upload a hare–lynx CSV first.", true);
  readCSV(f, rows=>{
    const colYear=pickColumn(rows,["Year","year","date","yr"],{fallbackNumeric:true});
    const colHare=pickColumn(rows,["Hare","hare","prey","hares","harecount"],{fallbackNumeric:true});
    const colLynx=pickColumn(rows,["Lynx","lynx","predator","lynxcount"],{fallbackNumeric:true});
    if(!colYear||!colHare||!colLynx) return setStatus("Couldn’t find Year/Hare/Lynx columns.", true);

    let T=rows.map(r=>({t:toNumber(r[colYear]), h:toNumber(r[colHare]), l:toNumber(r[colLynx])}))
              .filter(r=>r.t!=null&&r.h!=null&&r.l!=null).sort((a,b)=>a.t-b.t);
    if(T.length<3) return setStatus("Need ≥3 numeric rows.", true);
    const hare=T.map(r=>r.h), lynx=T.map(r=>r.l), idx=T.map((_,i)=>i);

    Plotly.newPlot("plot2",
      [{x:hare,y:lynx,mode:"lines",name:"path",line:{width:1.8}},
       {x:hare,y:lynx,mode:"markers",name:"time",marker:{size:6,color:idx,colorscale:"Blues",
         colorbar:{title:"order",x:1.21,thickness:12}},showlegend:true}],
      baseLayout("Phase Plane: Hare vs Lynx", {margin:{t:56,r:70,b:60,l:70}, xaxis:{title:{text:"Hare(t)"},tickformat:",~s"}, yaxis:{title:{text:"Lynx(t)"},tickformat:",~s"}}),
      config);

    const diag=(x,y)=>({x:[Math.min(...x,...y),Math.max(...x,...y)],y:[Math.min(...x,...y),Math.max(...x,...y)],mode:"lines",line:{dash:"dot"},hoverinfo:"skip",showlegend:false});
    const ht=hare.slice(0,-1), ht1=hare.slice(1), lt=lynx.slice(0,-1), lt1=lynx.slice(1);

    Plotly.newPlot("plot3",
      [{x:ht,y:ht1,mode:"markers",name:"Hare"}, diag(ht,ht1)],
      baseLayout("Return: Hare(t) → Hare(t+1)", {xaxis:{title:{text:"Hare(t)"},tickformat:",~s"}, yaxis:{title:{text:"Hare(t+1)"},tickformat:",~s"}}),
      config);
    Plotly.newPlot("plot4",
      [{x:lt,y:lt1,mode:"markers",name:"Lynx"}, diag(lt,lt1)],
      baseLayout("Return: Lynx(t) → Lynx(t+1)", {xaxis:{title:{text:"Lynx(t)"},tickformat:",~s"}, yaxis:{title:{text:"Lynx(t+1)"},tickformat:",~s"}}),
      config);

    setStatus("Hare–Lynx rendered (time-sorted, labels clear).");
  });
};

// ---------- Fitbit (24h Nightingale + weekday radar) ----------
document.getElementById("btn-make-fitbit").onclick = ()=>{
  const f=document.getElementById("file-fitbit").files[0]; if(!f) return setStatus("Upload a Fitbit/time CSV first.", true);
  readCSV(f, rows=>{
    const colTime=pickColumn(rows,["timestamp","time","datetime","date","ActivityMinute"]);
    const colSteps=pickColumn(rows,["steps","value","count","activity","stepcount","Steps"],{fallbackNumeric:true});
    if(!colTime||!colSteps) return setStatus("Couldn’t find time & steps columns.", true);

    const byHour=new Array(24).fill(0), dayTotals=new Array(7).fill(0), dowN=new Array(7).fill(0);
    for(const r of rows){
      const d=toDate(r[colTime]); const st=toNumber(r[colSteps]);
      if(!d||st==null) continue;
      byHour[d.getHours()]+=st;
      const k=(d.getDay()+6)%7; dayTotals[k]+=st; dowN[k]+=1;
    }
    const total = byHour.reduce((a,b)=>a+b,0)||1;

    // Nightingale: use hours, not degrees
    const theta = [...Array(24)].map((_,h)=>h*15); // purely for placements; we label hours
    const labels = [...Array(24)].map((_,h)=>`${h}:00`);
    Plotly.newPlot("plot5",
      [{type:"barpolar", r:byHour, theta, text:labels, hovertemplate:"%{text}<br>%{r:.0f} steps<extra></extra>", width:new Array(24).fill(360/24)}],
      polarLayout("Nightingale Rose: Value by Hour", {polar:{angularaxis:{tickmode:"array",tickvals:theta,ticktext:labels}}}),
      config);

    const means = dayTotals.map((s,i)=> dowN[i]?s/dowN[i]:0);
    const labelsD=["Mon","Tue","Wed","Thu","Fri","Sat","Sun"];
    const share = means.map(v=> 100*v/(means.reduce((a,b)=>a+b,0)||1));
    Plotly.newPlot("plot6",
      [{type:"scatterpolar", r:share.concat([share[0]]), theta:labelsD.concat([labelsD[0]]), mode:"lines+markers", fill:"toself",
        hovertemplate:"%{theta}: %{r:.1f}%<extra></extra>"}],
      polarLayout("Radar: Mean Steps Share by Day of Week"),
      config);

    setStatus("Fitbit rose & radar rendered (24-hour labels, shares by weekday).");
  });
};

// ---------- Tribolium (cobweb, with quadratic + ricker fits shown) ----------
document.getElementById("btn-make-trib").onclick = ()=>{
  const f=document.getElementById("file-trib").files[0]; if(!f) return setStatus("Upload a Tribolium CSV first.", true);
  readCSV(f, rows=>{
    const colVal=pickColumn(rows,["adults","count","population","value","n"],{fallbackNumeric:true});
    if(!colVal) return setStatus("Couldn’t find Adults/value column.", true);
    const series=toNumberArray(rows.map(r=>r[colVal]));
    if(series.length<5) return setStatus("Need ≥5 numeric rows.", true);

    const x=series.slice(0,-1), y=series.slice(1);
    // Quadratic fit
    const n=x.length; let Sx=0,Sx2=0,Sx3=0,Sx4=0,Sy=0,Sxy=0,Sx2y=0;
    for(let i=0;i<n;i++){ const xi=x[i], yi=y[i], x2=xi*xi; Sx+=xi; Sx2+=x2; Sx3+=x2*xi; Sx4+=x2*x2; Sy+=yi; Sxy+=xi*yi; Sx2y+=x2*yi; }
    function solve3(A,B){ const M=A.map((r,i)=>r.concat([B[i]])); const m=M.length;
      for(let k=0;k<m;k++){ let p=k; for(let i=k+1;i<m;i++) if(Math.abs(M[i][k])>Math.abs(M[p][k])) p=i;
        [M[k],M[p]]=[M[p],M[k]]; const piv=M[k][k]||1e-12; for(let j=k;j<=m;j++) M[k][j]/=piv;
        for(let i=0;i<m;i++) if(i!==k){ const f=M[i][k]; for(let j=k;j<=m;j++) M[i][j]-=f*M[k][j]; } }
      return M.map(r=>r[m]);
    }
    const [a,b,c]=solve3([[n,Sx,Sx2],[Sx,Sx2,Sx3],[Sx2,Sx3,Sx4]],[Sy,Sxy,Sx2y]);

    // Ricker fit by log-linear: y = x*exp(r*(1 - x/K))
    // Do a quick linearization on log(y/x)= r*(1-x/K)
    const lx = x.map((xi,i)=> xi>0 && y[i]>0 ? Math.log(y[i]/xi): null);
    const good = lx.map((v,i)=> v!=null && isFinite(v));
    const X = x.filter((_,i)=>good[i]); const L = lx.filter((_,i)=>good[i]);
    let rhat=NaN, Khat=NaN;
    if(X.length>3){
      // Fit L = alpha + beta*x  -> r = alpha,  -r/K = beta
      const n2=X.length; const Sx_=X.reduce((a,b)=>a+b,0), Sy_=L.reduce((a,b)=>a+b,0);
      const Sxx_=X.reduce((a,b)=>a+b*b,0), Sxy_=X.reduce((a,b,i)=>a+b*L[i],0);
      const denom = n2*Sxx_ - Sx_*Sx_ || 1e-12;
      const beta = (n2*Sxy_ - Sx_*Sy_)/denom;
      const alpha= (Sy_ - beta*Sx_)/n2;
      rhat = alpha; Khat = -rhat/beta;
    }

    const xmin=Math.min(...x,...y), xmax=Math.max(...x,...y);
    const xs=Array.from({length:400},(_,i)=> xmin+(xmax-xmin)*i/399);
    const fQ = xs.map(v=> a+b*v+c*v*v);
    const fR = xs.map(v=> (isFinite(rhat)&&isFinite(Khat)) ? v*Math.exp(rhat*(1 - v/(Khat||1e-9))) : NaN );

    const base = [
      {x:x, y:y, mode:"markers", name:"data", opacity:0.6},
      {x:xs, y:fQ, mode:"lines", name:`Quadratic`},
      {x:xs, y:fR, mode:"lines", line:{dash:"dash"}, name:`Ricker`}
    ];
    const diag={x:[xmin,xmax],y:[xmin,xmax],mode:"lines",line:{dash:"dot"},hoverinfo:"skip",showlegend:false};
    Plotly.newPlot("plot1", base.concat([diag]),
      baseLayout("Cobweb (map fit) – Tribolium", {xaxis:{title:{text:"x(t)"}},yaxis:{title:{text:"x(t+1)"}}}),
      config);
    setStatus(`Tribolium: n=${n}. Fit used: Quadratic${isFinite(rhat)?", Ricker":""}.`);
  });
};

// ---------- Mites (Predator–Prey) ----------
document.getElementById("btn-make-mites").onclick = ()=>{
  const f=document.getElementById("file-mites").files[0]; if(!f) return setStatus("Upload a Mites (predator–prey) CSV first.", true);
  const doDecum=document.getElementById("cb-decum").checked;
  const doZ=document.getElementById("cb-znorm").checked;

  readCSV(f, rows=>{
    const colT=pickColumn(rows,["time","t","date","datetime"],{fallbackNumeric:false});
    const colPrey=pickColumn(rows,["prey","host","victim","preycount"],{fallbackNumeric:true});
    const colPred=pickColumn(rows,["pred","predator","enemy","predcount"],{fallbackNumeric:true});
    if(!colT||!colPrey||!colPred) return setStatus("Need time + prey + predator columns.", true);

    let T=rows.map(r=>({t:toDate(r[colT])||toNumber(r[colT]), prey:toNumber(r[colPrey]), pred:toNumber(r[colPred])}))
              .filter(r=>r.t!=null&&r.prey!=null&&r.pred!=null);
    // sort by time
    T.sort((a,b)=> (a.t>b.t)-(a.t<b.t));
    if(T.length<8) return setStatus("Need ≥8 time-ordered rows.", true);

    // detect cumulative
    function likelyCumulative(arr){
      const diffs = arr.slice(1).map((v,i)=> v-arr[i]);
      const pos = diffs.filter(d=>d>=0).length / diffs.length;
      const mono = pos>0.9;
      const backsteps = diffs.filter(d=>d<0).length;
      return mono && backsteps<=1;
    }
    let prey=T.map(r=>r.prey), pred=T.map(r=>r.pred);

    if(doDecum){
      const preyCum = likelyCumulative(prey), predCum = likelyCumulative(pred);
      if(preyCum) prey = prey.slice(1).map((v,i)=>v - prey[i]);
      if(predCum) pred = pred.slice(1).map((v,i)=>v - pred[i]);
      if(preyCum || predCum){ T=T.slice(1); setStatus(`Applied de-cumulative fix: prey=${preyCum}, predator=${predCum}.`); }
    }

    // sanitize: nonnegative
    prey = prey.map(v=> (v!=null&&isFinite(v))? v:0);
    pred = pred.map(v=> (v!=null&&isFinite(v))? v:0);

    // Z-normalize if asked (for geometry; keep raw for labels)
    const z = (a)=>{ const m=a.reduce((s,v)=>s+v,0)/a.length; const sd=Math.sqrt(a.reduce((s,v)=>s+(v-m)*(v-m),0)/(a.length-1)||1); return a.map(v=>(v-m)/sd); };
    const P = doZ ? z(prey) : prey;
    const R = doZ ? z(pred) : pred;

    const idx = T.map((_,i)=>i);

    // Phase plane
    Plotly.newPlot("plot2",
      [
        {x:P, y:R, mode:"lines", name:"path", line:{width:1.8}},
        {x:P, y:R, mode:"markers", name:"time", marker:{size:6,color:idx,colorscale:"Blues",
          colorbar:{title:"order", x:1.21, thickness:12}}, showlegend:true}
      ],
      baseLayout("Phase Plane: Prey vs Predator", {margin:{t:56,r:70,b:60,l:70}, xaxis:{title:{text: doZ?"Prey (z)":"Prey(t)"}}, yaxis:{title:{text: doZ?"Predator (z)":"Predator(t)"}}}),
      config
    );

    // helper: diag + LS + LOWESS
    function diag(x,y){ const lo=Math.min(...x,...y), hi=Math.max(...x,...y);
      return {x:[lo,hi],y:[lo,hi],mode:"lines",line:{dash:"dot"},hoverinfo:"skip",showlegend:false}; }
    function lsfit(x,y){ const n=x.length; const sx=x.reduce((a,b)=>a+b,0), sy=y.reduce((a,b)=>a+b,0);
      const sxx=x.reduce((a,b)=>a+b*b,0), sxy=x.reduce((a,b,i)=>a+b*y[i],0);
      const den = n*sxx - sx*sx || 1e-12; const b = (n*sxy - sx*sy)/den; const a = (sy - b*sx)/n;
      const lo=Math.min(...x), hi=Math.max(...x); const xs=[lo,hi]; const ys=xs.map(v=>a+b*v);
      return {xs, ys, a, b};
    }
    function lowess(x,y,f=0.3, it=1){ // tiny LOWESS
      const n=x.length, r=Math.ceil(f*n); const ys=new Array(n).fill(0);
      for(let i=0;i<n;i++){
        const d = x.map((v,j)=>({j, w:Math.abs(v - x[i])})).sort((a,b)=>a.w-b.w);
        const nn=d[r-1].w||1e-12;
        const w = d.map(o=>{ const u=Math.abs(x[o.j]-x[i])/nn; return (u>=1)?0:Math.pow(1-u*u,2); });
        let sw=0,sx=0,sy_=0,sxx=0,sxy=0;
        for(let k=0;k<n;k++){ const wk=w[k]; sw+=wk; sx+=wk*x[k]; sy_+=wk*y[k]; sxx+=wk*x[k]*x[k]; sxy+=wk*x[k]*y[k]; }
        const den=sw*sxx - sx*sx || 1e-12; const b=(sw*sxy - sx*sy_)/den; const a=(sy_ - b*sx)/sw;
        ys[i]=a + b*x[i];
      }
      return ys;
    }

    const Pt=P.slice(0,-1), Pt1=P.slice(1);
    const Rt=R.slice(0,-1), Rt1=R.slice(1);

    const fitP=lsfit(Pt,Pt1), fitR=lsfit(Rt,Rt1);
    const smP=lowess(Pt,Pt1), smR=lowess(Rt,Rt1);

    Plotly.newPlot("plot3",
      [
        {x:Pt, y:Pt1, mode:"markers", name:"Return", marker:{opacity:.7}},
        {x:fitP.xs, y:fitP.ys, mode:"lines", name:"LS fit"},
        {x:Pt, y:smP, mode:"lines", name:"LOWESS", line:{dash:"dash"}},
        diag(Pt,Pt1)
      ],
      baseLayout("Return: Prey(t) → Prey(t+1)", {xaxis:{title:{text:doZ?"Prey (z)":"Prey(t)"}}, yaxis:{title:{text:doZ?"Prey (z, +1)":"Prey(t+1)"}}}),
      config
    );

    Plotly.newPlot("plot4",
      [
        {x:Rt, y:Rt1, mode:"markers", name:"Return", marker:{opacity:.7}},
        {x:fitR.xs, y:fitR.ys, mode:"lines", name:"LS fit"},
        {x:Rt, y:smR, mode:"lines", name:"LOWESS", line:{dash:"dash"}},
        diag(Rt,Rt1)
      ],
      baseLayout("Return: Predator(t) → Predator(t+1)", {xaxis:{title:{text:doZ?"Predator (z)":"Predator(t)"}}, yaxis:{title:{text:doZ?"Predator (z, +1)":"Predator(t+1)"}}}),
      config
    );

    setStatus("Mites: phase plane & return maps rendered. If lines look too linear: uncheck Z-normalize to inspect scale, or verify your CSV isn’t cumulative.");
  });
};
</script>
</body>
</html>





